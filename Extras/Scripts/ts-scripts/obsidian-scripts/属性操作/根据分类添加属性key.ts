/*
- Author: Generated by AI (based on existing PARA script)
- Create Time: 2025-01-12
- Description: 根据当前文件frontmatter中的"分类"包含的值，获取对应文件的frontmatter全部属性key（排除tags和"描述"），智能切换：如果当前文件已包含这些属性则删除，否则添加
- Warning: 文件开头不要放任何非注释文本。
- Version: 1.1 (添加了切换功能)
*/

// Obsidian 类型声明（仅用于 TypeScript 编译，运行时由 Obsidian 提供）
declare const app: any;
declare const Notice: any;

// --- 配置项 ---
const categoryProperty = "分类"; // 当前文件中的分类属性名
const excludeKeys = ["tags", "描述", "icon", "分类"]; // 需要排除的属性key列表
// --- END ---

/**
 * 解析双链格式，提取文件名
 * @param link 双链格式的字符串，如 "[[AI生成 - fileclass]]"
 * @returns 解析后的文件名，如 "AI生成 - fileclass"
 */
function parseWikiLink(link: any): string | null {
    // 类型检查：确保link是字符串
    if (typeof link !== 'string') {
        console.warn(`分类值不是字符串类型: ${typeof link}, 值: ${link}`);
        return null;
    }

    const wikiLinkRegex = /\[\[([^\]]+)\]\]/;
    const match = link.match(wikiLinkRegex);
    return match ? match[1] : null;
}

/**
 * 获取文件的frontmatter
 * @param fileName 文件名（可以是带或不带扩展名的）
 * @returns 文件的frontmatter对象，如果文件不存在或无frontmatter则返回null
 */
async function getFileFrontmatter(fileName: string): Promise<any> {
    try {
        let file = null;

        // 1. 尝试精确匹配（带.md扩展名）
        file = app.vault.getAbstractFileByPath(`${fileName}.md`);

        // 2. 尝试精确匹配（不带扩展名）
        if (!file) {
            file = app.vault.getAbstractFileByPath(fileName);
        }

        // 3. 如果都找不到，尝试智能查找
        if (!file) {
            const allFiles = app.vault.getAllLoadedFiles();

            // 查找文件名完全匹配的文件（不区分扩展名）
            for (const f of allFiles) {
                if (f.name.replace(/\.md$/, '') === fileName ||
                    f.basename === fileName ||
                    f.name === `${fileName}.md`) {
                    file = f;
                    break;
                }
            }

            // 如果还是找不到，尝试部分匹配
            if (!file) {
                for (const f of allFiles) {
                    if (f.name.toLowerCase().includes(fileName.toLowerCase()) ||
                        f.basename.toLowerCase().includes(fileName.toLowerCase())) {
                        console.log(`找到可能的匹配文件: ${f.path}`);
                        file = f;
                        break;
                    }
                }
            }
        }

        if (!file) {
            console.warn(`文件 "${fileName}" 不存在，已尝试多种查找方式`);
            return null;
        }

        // 检查是否是TFile类型
        if (!file || typeof file !== 'object' || !('extension' in file)) {
            console.warn(`文件 "${fileName}" 不是有效的文件类型`);
            return null;
        }

        // 使用Obsidian的metadata cache获取frontmatter
        const metadata = app.metadataCache.getFileCache(file);
        if (!metadata) {
            console.warn(`无法获取文件 "${fileName}" 的元数据`);
            return null;
        }

        if (!metadata.frontmatter) {
            console.warn(`文件 "${fileName}" 没有frontmatter`);
            return null;
        }

        console.log(`成功读取文件: ${(file as any).path || fileName}`);
        return metadata.frontmatter;
    } catch (error) {
        console.error(`读取文件 "${fileName}" 时出错:`, error);
        return null;
    }
}

/**
 * 获取分类对应文件的属性key列表
 * @param categoryValue 分类属性的值
 * @returns 属性key列表
 */
async function getCategoryPropertyKeys(categoryValue: any): Promise<string[]> {
    // 检查categoryValue是否存在且不为空
    if (!categoryValue) {
        console.warn(`分类值为空: ${categoryValue}`);
        return [];
    }

    const fileName = parseWikiLink(categoryValue);
    if (!fileName) {
        console.warn(`无法解析分类值: ${categoryValue} (类型: ${typeof categoryValue})`);
        return [];
    }

    const categoryFrontmatter = await getFileFrontmatter(fileName);
    if (!categoryFrontmatter) {
        return [];
    }

    // 获取所有key并过滤排除的key
    const allKeys = Object.keys(categoryFrontmatter);
    return allKeys.filter(key => !excludeKeys.includes(key));
}

/**
 * 检查当前文件是否已经包含了指定的属性key
 * @param currentFm 当前文件的frontmatter
 * @param keys 要检查的属性key列表
 * @returns 包含的属性数量
 */
function checkExistingKeys(currentFm: any, keys: string[]): number {
    let existingCount = 0;

    for (const key of keys) {
        if (key in currentFm) {
            existingCount++;
        }
    }

    return existingCount;
}

/**
 * 添加属性key到当前文件的frontmatter
 * @param currentFm 当前文件的frontmatter
 * @param newKeys 需要添加的属性key列表
 * @returns 添加的属性数量
 */
function addPropertyKeys(currentFm: any, newKeys: string[]): number {
    let addedCount = 0;

    for (const key of newKeys) {
        if (!(key in currentFm)) {
            currentFm[key] = ""; // 直接修改原对象
            addedCount++;
        }
    }

    return addedCount;
}

/**
 * 从当前文件的frontmatter中删除指定的属性key
 * @param currentFm 当前文件的frontmatter
 * @param keysToRemove 需要删除的属性key列表
 * @returns 删除的属性数量
 */
function removePropertyKeys(currentFm: any, keysToRemove: string[]): number {
    let removedCount = 0;

    for (const key of keysToRemove) {
        if (key in currentFm) {
            delete currentFm[key];
            removedCount++;
        }
    }

    return removedCount;
}

async function main() {
    const activeFile = app.workspace.getActiveFile();
    if (!activeFile) {
        new Notice("错误：无法找到当前文件。", 5000);
        return;
    }

    const noteName = activeFile.basename;

    // 先异步获取所有需要的属性key
    try {
        // 检查是否存在分类属性
        const currentFm = app.metadataCache.getFileCache(activeFile)?.frontmatter;
        if (!currentFm || !(categoryProperty in currentFm) || currentFm[categoryProperty] === null || currentFm[categoryProperty] === undefined) {
            new Notice(`当前文件 "${noteName}" 没有"${categoryProperty}"属性或属性值为空。`, 3000);
            return;
        }

        const categoryValue = currentFm[categoryProperty];

        // 检查分类值是否为有效类型
        if (typeof categoryValue !== 'string' && !Array.isArray(categoryValue)) {
            new Notice(`当前文件 "${noteName}" 的"${categoryProperty}"属性值不是字符串或数组类型 (类型: ${typeof categoryValue})。`, 5000);
            return;
        }

        // 获取分类对应文件的属性key
        let propertyKeys: string[] = [];

        if (typeof categoryValue === 'string') {
            // 处理单个字符串分类
            if (categoryValue.trim() === '') {
                new Notice(`当前文件 "${noteName}" 的"${categoryProperty}"属性值为空字符串。`, 3000);
                return;
            }
            propertyKeys = await getCategoryPropertyKeys(categoryValue);
        } else if (Array.isArray(categoryValue)) {
            // 处理数组类型的分类
            if (categoryValue.length === 0) {
                new Notice(`当前文件 "${noteName}" 的"${categoryProperty}"属性值为空数组。`, 3000);
                return;
            }

            // 遍历数组中的每个分类，收集所有属性key
            const allPropertyKeys: string[] = [];
            for (const categoryItem of categoryValue) {
                if (typeof categoryItem === 'string' && categoryItem.trim() !== '') {
                    const keys = await getCategoryPropertyKeys(categoryItem);
                    allPropertyKeys.push(...keys);
                }
            }

            // 去重并保持顺序
            propertyKeys = [...new Set(allPropertyKeys)];
        }

        if (propertyKeys.length === 0) {
            new Notice(`无法从分类 "${categoryValue}" 获取属性key，或对应文件不存在。`, 3000);
            return;
        }

        // 在同步的processFrontMatter中应用更改
        app.fileManager.processFrontMatter(activeFile, (fm: any) => {
            try {
                // 检查当前文件是否已经包含了这些属性
                const existingCount = checkExistingKeys(fm, propertyKeys);

                console.log(`属性key列表: ${propertyKeys.join(', ')}`);
                console.log(`当前文件已包含 ${existingCount} 个属性`);

                let resultMessage = '';
                let resultCount = 0;

                if (existingCount > 0) {
                    // 如果已经包含了属性，则删除这些属性
                    resultCount = removePropertyKeys(fm, propertyKeys);
                    resultMessage = `已从文件 "${noteName}" 删除 ${resultCount} 个属性key。`;
                    console.log(`正在删除属性: ${propertyKeys.join(', ')}`);
                } else {
                    // 如果没有包含，则添加这些属性
                    resultCount = addPropertyKeys(fm, propertyKeys);
                    if (resultCount === 0) {
                        new Notice(`当前文件 "${noteName}" 已经包含所有分类属性。`, 3000);
                        return;
                    }
                    resultMessage = `已为文件 "${noteName}" 添加 ${resultCount} 个属性key。`;
                    console.log(`正在添加属性: ${propertyKeys.join(', ')}`);
                }

                new Notice(resultMessage, 3000);

            } catch (e) {
                const errorMessage = `为文件 "${noteName}" 处理属性key时出错: ${(e as Error).message}`;
                new Notice(errorMessage, 5000);
                console.error(errorMessage);
            }
        });

    } catch (e) {
        const errorMessage = `为文件 "${noteName}" 准备属性key时出错: ${(e as Error).message}`;
        new Notice(errorMessage, 5000);
        console.error(errorMessage);
    }
}

export async function invoke() {
    await main();
}
